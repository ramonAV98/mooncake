import math

import numpy as np
import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin

from ..utils import undo_sliding_window


class PassNPeriod:
    """
    TODO: FILL NANS

    Use with: https://scikit-learn.org/0.18/modules/generated/sklearn.pipeline.FeatureUnion.html#sklearn.pipeline.FeatureUnion
    """

    conversions_date = {"Y": "years", "D": "days", "M": "months"}

    def __init__(self, target_col="SALE_UNITS", date_col="SALE_DATE",
                 group_by="Y", pass_n=1):
        self.target_col = target_col
        self.date_col = date_col
        self.group_by = group_by
        self.pass_n = pass_n

    def fit(self, X, y=None):
        return self

    def transform(self, df):
        df_ = df.copy().set_index(self.date_col)
        k = self.conversions_date[self.group_by]
        result = df_.resample(self.group_by).mean().reindex(df_.index,
                                                            method='bfill')
        result.reset_index(inplace=True)
        columns = {
            self.target_col: "PASS_%s%s_%s" % (self.pass_n, k.upper(),
                                               self.target_col.upper())
        }
        result.rename(columns=columns, inplace=True)
        params = {k: self.pass_n}
        result[self.date_col] = result[self.date_col] + pd.DateOffset(**params)
        return df.merge(result, on=self.date_col, how="left")


class SlidingWindow(BaseEstimator, TransformerMixin):
    """Transforms n-dimensional data into sliding sequences.

    Parameters
    ----------
    columns : list of str
        Columns for which the sliding sequences will be created

    sequence_length : int
        Length for each sequence

    step : int
        Gap between sequences
    """

    def __init__(self, columns, sequence_length, step):
        self.columns = columns
        self.sequence_length = sequence_length
        self.step = step

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        """Transforms n-dimensional data into sliding sequences

        Parameters
        ----------
        X : pd.DataFrame

        Returns
        -------
        np.ndarray
            np.ndarray of shape (N, ``sequence_length``, ``columns``) where
            N is the total number of sliding sequences created
        """
        Xs = self._fill_sliding_seqs(X)
        Xs = self._slice_sliding_seqs(Xs, len(X))
        return Xs

    def inverse_transform(self, X, reverse=False):
        """Undoes sliding window and recovers original ``X``

        Parameters
        ----------
        X : numpy ndarray

        Returns
        -------
        inv trans X : np.ndarray
        """
        return undo_sliding_window(X, self.step, reverse)

    def _fill_sliding_seqs(self, X):
        """The sliding sequences are populated using the pd.shift operator.
        """
        numeric_cols = X[self.columns].select_dtypes(include=np.number).columns
        dtype = float if len(numeric_cols) == len(self.columns) else object
        # The ceil operator allows to keep the last possible sequence
        # containing nans
        len_sliding_sequences = math.ceil(len(X) / self.step)
        # Holder for sliding sequences
        sliding_sequences = np.zeros(
            (len_sliding_sequences, self.sequence_length, len(self.columns)),
            dtype=dtype
        )
        for j in range(self.sequence_length):
            sliding_sequences[:, j, :] = X[self.columns].shift(-j)[::self.step]
        return sliding_sequences

    def _slice_sliding_seqs(self, X, original_length):
        """Drops sliding windows nans.

        There are two sources of nans:

        - Those generated by the shift operator in _fill_sliding_sequences
        - The training sequences whose target sequences will contain nans
        """
        all_starting_index = np.array(range(original_length)[::self.step])
        all_ending_lengths = all_starting_index + self.sequence_length
        arrays_with_nan = len(
            all_ending_lengths[all_ending_lengths > original_length]
        )
        return X[0:-arrays_with_nan] if arrays_with_nan != 0 else X

    def _more_tags(self):
        return {'stateless': True}
