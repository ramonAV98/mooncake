import math

import numpy as np
import pandas as pd
from sklearn.base import BaseEstimator, TransformerMixin


def inverse_transform_sliding_window(X, step=1, reverse=False):
    """Inverse transformation for sliding windows data structure

    Parameters
    ----------
    X : np.ndarray
        ndarray containing arrays in sliding format

    step : int
        step used for constructing the sliding windows

    reverse : bool
        If True, the inverse transfrom is performed fromm end to start.
        Otherwise, from start to end.

    Returns
    -------
    np.ndarray

    Examples
    --------
    # Undo sliding window with sequence_length=3 and step=1
    >>> X = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5]])
    >>> inverse_transform_sliding_window(X, step=1)
    array([[1],
           [2],
           [3],
           [4],
           [5]])
    """
    if not len(X.shape) > 1:
        raise ValueError(
            'X must have 2 or more dimensions of any size.'
            'Instead got shape: {}'.format(X.shape)
        )
    np_X = np.array(X)
    if len(np_X.shape) == 2:
        np_X = np.expand_dims(np_X, axis=2)
    a = np.concatenate(np_X[:, :step, :])
    b = np_X[-1, step:, :]
    inverse = np.concatenate((a, b))
    return inverse if not reverse else inverse[::-1]


class SlidingWindow(BaseEstimator, TransformerMixin):
    """Transforms n-dimensional data into sliding sequences.

    Parameters
    ----------
    columns : list of str
        Columns for which the sliding sequences will be created

    sequence_length : int
        Length for each sequence

    step : int
        Gap between sequences
    """

    def __init__(self, columns, sequence_length, step):
        self.columns = columns
        self.sequence_length = sequence_length
        self.step = step

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        """Transforms n-dimensional data into sliding sequences

        Parameters
        ----------
        X : pd.DataFrame

        Returns
        -------
        np.ndarray
            np.ndarray of shape (N, ``sequence_length``, ``columns``) where
            N is the total number of sliding sequences created
        """
        Xs = self._fill_sliding_seqs(X)
        Xs = self._slice_sliding_seqs(Xs, len(X))
        return Xs

    def inverse_transform(self, X, reverse=False):
        """Undoes sliding window and recovers original ``X``

        Parameters
        ----------
        X : numpy ndarray

        Returns
        -------
        inv trans X : np.ndarray
        """
        return inverse_transform_sliding_window(X, self.step, reverse)

    def _fill_sliding_seqs(self, X):
        """The sliding sequences are populated using the pd.shift operator.
        """
        numeric_cols = X[self.columns].select_dtypes(include=np.number).columns
        dtype = float if len(numeric_cols) == len(self.columns) else object
        # The ceil operator allows to keep the last possible sequence
        # containing nans
        len_sliding_sequences = math.ceil(len(X) / self.step)
        # Holder for sliding sequences
        sliding_sequences = np.zeros(
            (len_sliding_sequences, self.sequence_length, len(self.columns)),
            dtype=dtype
        )
        for j in range(self.sequence_length):
            sliding_sequences[:, j, :] = X[self.columns].shift(-j)[::self.step]
        return sliding_sequences

    def _slice_sliding_seqs(self, X, original_length):
        """Drops sliding windows nans.

        There are two sources of nans:

        - Those generated by the shift operator in _fill_sliding_sequences
        - The training sequences whose target sequences will contain nans
        """
        all_starting_index = np.array(range(original_length)[::self.step])
        all_ending_lengths = all_starting_index + self.sequence_length
        arrays_with_nan = len(
            all_ending_lengths[all_ending_lengths > original_length]
        )
        return X[0:-arrays_with_nan] if arrays_with_nan != 0 else X

    def _more_tags(self):
        return {'stateless': True}
